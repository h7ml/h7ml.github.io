import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as t}from"./app-Cbix2SPG.js";const e={},p=t(`<p>控制反转（IOC）和依赖注入（DI）是面向对象编程中的重要设计原则，用于降低代码间的耦合度，并提高可维护性和可测试性。本文将介绍 IOC 和 DI 的概念、解决的问题、实现思路以及在 Nest 框架中的具体实现。</p><h2 id="什么是-ioc" tabindex="-1"><a class="header-anchor" href="#什么是-ioc"><span>什么是 IOC</span></a></h2><p>IOC（Inversion of Control，控制反转）是一种设计原则，通过将对象的创建和管理交给一个容器来实现。在非 IOC 模式下，对象之间的依赖关系由调用者来控制和管理。而在 IOC 模式下，对象的创建和依赖关系的管理都由容器来完成，从而实现了对象之间的解耦。</p><h3 id="要解决的问题" tabindex="-1"><a class="header-anchor" href="#要解决的问题"><span>要解决的问题</span></a></h3><p>在非 IOC 模式下，如果一个类 B 需要使用类 A 的实例，通常会在 B 中创建 A 的实例对象。而如果类 C 又依赖于类 B，这种控制权的嵌套会持续下去，导致依赖关系变得复杂。例如，在一个典型的三层架构中，Controller 依赖于 Service 来实现业务逻辑，Service 依赖于 Repository 来进行数据库操作，Repository 又依赖于 DataSource 来建立数据库连接，而 DataSource 需要从 Config 对象中获取用户名密码等信息。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">{</span> username<span class="token operator">:</span> <span class="token string">&#39;xxx&#39;</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token string">&#39;xxx&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSource</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> repository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Repository</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">(</span>repository<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Controller</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>上述代码存在两个问题： <ol><li>依赖关系复杂，对象的创建必须按照特定顺序实例化。</li><li>这些对象不需要每次都创建新的实例，应该使用单例模式。</li></ol></li></ul><h3 id="实现思路" tabindex="-1"><a class="header-anchor" href="#实现思路"><span>实现思路</span></a></h3><p>在 IOC 模式下，不再由调用者来查找和创建类的实例，而是将这些职责交给一个容器来管理，以实现类与类之间的解耦。</p><h2 id="di" tabindex="-1"><a class="header-anchor" href="#di"><span>DI</span></a></h2><p>依赖注入（Dependency Injection，DI）是实现控制反转的一种常用方式。在 DI 中，程序会在初始化时扫描类之间的依赖关系，并将这些类的实例注入到容器中。</p><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h3><p>在初始化时，程序会扫描类之间的依赖关系，并将这些类的实例放入容器中。在创建对象时，程序会根据类的依赖关系，将相应的依赖对象注入到类中。</p><h3 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h3><p>IOC 模式是与语言无关的，不同的框架对 DI 的实现方式也有所不同。</p><ul><li>在 Java 的 Spring 框架中，可以通过定义 XML 文件来决定类之间的依赖关系。</li><li>在 Nest 框架中，可以通过装饰器和元数据来实现 DI。在 Nest 框架中，基于 Reflect 的 MetaData 实现了自动分析模块之间的依赖关系。可以使用 Reflect.defineMetadata 和 Reflect.getMetadata 方法来设置和读取类或类属性的元数据。通过配合装饰器语法，可以实现依赖注入。</li></ul><p>以下是一个使用 Nest 框架的装饰器实现的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> Inject<span class="token punctuation">,</span> CallHandler<span class="token punctuation">,</span> ExecutionContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/common&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> Inject<span class="token punctuation">,</span> CallHandler<span class="token punctuation">,</span> ExecutionContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/common&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Reflector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/core&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;rxjs&#39;</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span>Reflector<span class="token punctuation">)</span>
  <span class="token keyword">private</span> reflector<span class="token operator">:</span> Reflector<span class="token punctuation">;</span>

  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;roles&#39;</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;roles&#39;</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ioc-和-di-的关系" tabindex="-1"><a class="header-anchor" href="#ioc-和-di-的关系"><span>IOC 和 DI 的关系</span></a></h2><p>控制反转是一种设计原则，而依赖注入是实现 IOC 的一种常用方式。除了依赖注入，还有其他实现 IOC 的方式，比如依赖查找（Dependency Lookup）等。</p><h2 id="解决循环引用问题" tabindex="-1"><a class="header-anchor" href="#解决循环引用问题"><span>解决循环引用问题</span></a></h2><p>在模块和服务之间可能存在相互引用的情况，这样就会出现循环依赖。Nest 框架通过使用 forwardRef 来解决循环引用的问题。forwardRef 可以在模块之间创建一个转发引用，Nest 会单独创建这两个模块，并将它们关联起来。</p><h3 id="模块中的使用示例" tabindex="-1"><a class="header-anchor" href="#模块中的使用示例"><span>模块中的使用示例：</span></a></h3><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> BModule<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="服务中的使用示例" tabindex="-1"><a class="header-anchor" href="#服务中的使用示例"><span>服务中的使用示例：</span></a></h3><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> BService<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">private</span> bService<span class="token operator">:</span> BService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是关于控制反转（IOC）与依赖注入（DI）的更深入介绍。通过 IOC 和 DI 的应用，可以实现代码的解耦和提高可维护性。在 Nest 框架中，通过装饰器和元数据的使用，可以更便捷地实现依赖注入。同时，使用 forwardRef 可以解决循环引用的问题，确保模块和服务之间的依赖关系正确建立。</p>`,27),o=[p];function c(l,i){return s(),a("div",null,o)}const k=n(e,[["render",c],["__file","IOC-DL.html.vue"]]),d=JSON.parse(`{"path":"/posts/Nestjs/IOC-DL.html","title":"控制反转（IOC）与依赖注入（DI）","lang":"zh-CN","frontmatter":{"icon":"generic","order":1,"date":"2024-07-14T00:00:00.000Z","author":"h7ml","title":"控制反转（IOC）与依赖注入（DI）","description":"nestjs  控制反转（IOC）与依赖注入（DI）","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>nestjs  控制反转（IOC）与依赖注入（DI）","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"nestjs  控制反转（IOC）与依赖注入（DI）","category":["IOC","DI","nestjs"],"tag":["DI","IOC","nestjs"],"head":[["meta",{"name":"keywords","content":"nestjs  控制反转（IOC）与依赖注入（DI）"}],["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/Nestjs/IOC-DL.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/Nestjs/IOC-DL.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"控制反转（IOC）与依赖注入（DI）"}],["meta",{"property":"og:description","content":"nestjs  控制反转（IOC）与依赖注入（DI）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.h7ml.cn/logo.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-13T20:13:02.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://www.h7ml.cn/logo.png"}],["meta",{"name":"twitter:image:alt","content":"控制反转（IOC）与依赖注入（DI）"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"DI"}],["meta",{"property":"article:tag","content":"IOC"}],["meta",{"property":"article:tag","content":"nestjs"}],["meta",{"property":"article:published_time","content":"2024-07-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-13T20:13:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"控制反转（IOC）与依赖注入（DI）\\",\\"image\\":[\\"https://www.h7ml.cn/logo.png\\"],\\"datePublished\\":\\"2024-07-14T00:00:00.000Z\\",\\"dateModified\\":\\"2023-07-13T20:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[{"level":2,"title":"什么是 IOC","slug":"什么是-ioc","link":"#什么是-ioc","children":[{"level":3,"title":"要解决的问题","slug":"要解决的问题","link":"#要解决的问题","children":[]},{"level":3,"title":"实现思路","slug":"实现思路","link":"#实现思路","children":[]}]},{"level":2,"title":"DI","slug":"di","link":"#di","children":[{"level":3,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":3,"title":"具体实现","slug":"具体实现","link":"#具体实现","children":[]}]},{"level":2,"title":"IOC 和 DI 的关系","slug":"ioc-和-di-的关系","link":"#ioc-和-di-的关系","children":[]},{"level":2,"title":"解决循环引用问题","slug":"解决循环引用问题","link":"#解决循环引用问题","children":[{"level":3,"title":"模块中的使用示例：","slug":"模块中的使用示例","link":"#模块中的使用示例","children":[]},{"level":3,"title":"服务中的使用示例：","slug":"服务中的使用示例","link":"#服务中的使用示例","children":[]}]}],"git":{"createdTime":1689270753000,"updatedTime":1689279182000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":2}]},"readingTime":{"minutes":4.03,"words":1210},"filePathRelative":"posts/Nestjs/IOC-DL.md","localizedDate":"2024年7月14日","excerpt":"<p>控制反转（IOC）和依赖注入（DI）是面向对象编程中的重要设计原则，用于降低代码间的耦合度，并提高可维护性和可测试性。本文将介绍 IOC 和 DI 的概念、解决的问题、实现思路以及在 Nest 框架中的具体实现。</p>\\n<h2>什么是 IOC</h2>\\n<p>IOC（Inversion of Control，控制反转）是一种设计原则，通过将对象的创建和管理交给一个容器来实现。在非 IOC 模式下，对象之间的依赖关系由调用者来控制和管理。而在 IOC 模式下，对象的创建和依赖关系的管理都由容器来完成，从而实现了对象之间的解耦。</p>\\n<h3>要解决的问题</h3>\\n<p>在非 IOC 模式下，如果一个类 B 需要使用类 A 的实例，通常会在 B 中创建 A 的实例对象。而如果类 C 又依赖于类 B，这种控制权的嵌套会持续下去，导致依赖关系变得复杂。例如，在一个典型的三层架构中，Controller 依赖于 Service 来实现业务逻辑，Service 依赖于 Repository 来进行数据库操作，Repository 又依赖于 DataSource 来建立数据库连接，而 DataSource 需要从 Config 对象中获取用户名密码等信息。</p>"}`);export{k as comp,d as data};
