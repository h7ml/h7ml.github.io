import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as i,c as p,d as e,e as t,a as o,f as r}from"./app-Cbix2SPG.js";const c={},l={href:"https://www.h7ml.cn/designPattern/",target:"_blank",rel:"noopener noreferrer"},d=e("h1",{id:"单一职责原则-srp-single-responsibility-principle",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#单一职责原则-srp-single-responsibility-principle"},[e("span",null,"单一职责原则 SRP(Single Responsibility Principle)")])],-1),h=e("blockquote",null,[e("p",null,'There should never be more than one reason for a class to change." In other words, every class should have only one responsibility.')],-1),m=e("p",null,[t("定义：一个类或者模块应该有且只有一个改变的原因，在 "),e("code",null,"js"),t(" 中的话更多的会应用在对象、函数中。")],-1),g=e("p",null,"最难的地方就在于结合具体场景对单一职责的判定了，为了应用这个原则把一个模块拆的太细其实也不太好，所以需要我们在方便性和稳定性之间做一个权衡。",-1),u={href:"https://www.h7ml.cn/designPattern/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.h7ml.cn/designPattern/decorator.html",target:"_blank",rel:"noopener noreferrer"},b=e("h1",{id:"开闭原则-ocp-open–closed-principle",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#开闭原则-ocp-open–closed-principle"},[e("span",null,"开闭原则 OCP(open–closed principle)")])],-1),w=e("blockquote",null,[e("p",null,"Software entities should be open for extension, but closed for modification.")],-1),_=e("p",null,"定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原代码的情况下进行扩展。",-1),y=e("p",null,"平常开发中，要把变的部分和不变的部分分离出来，设计一个结构的时候尽可能的考虑一下未来可能变化的部分。",-1),k=e("p",null,[t("可以通过放置 "),e("code",null,"hook"),t(" 、使用回调函数的方式达到扩展的目的。")],-1),P={href:"https://www.h7ml.cn/designPattern/publishSubscribe.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.h7ml.cn/designPattern/template.html",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.h7ml.cn/designPattern/strategy.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://www.h7ml.cn/designPattern/chainofresponsibility.html",target:"_blank",rel:"noopener noreferrer"},D=r('<h1 id="里氏替换原则-lsp-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp-liskov-substitution-principle"><span>里氏替换原则 LSP(Liskov substitution principle)</span></a></h1><blockquote><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>定义：所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。</p><p>举个例子就是如果某个地方可以用 <code>A</code> 类， <code>B</code> 类继承于 <code>A</code> 类，那么这个地方一定可以使用 <code>B</code> 类。</p><p>这个原则告诉我们在继承类的时候，如果要实现一个新功能，不要去覆盖父类已经实现的方法，而应该去写一个新方法。</p><p>平常前端开发中很少去写类和继承，这个原则用的比较少。</p><h1 id="接口隔离原则-isp-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-isp-interface-segregation-principle"><span>接口隔离原则 ISP(Interface Segregation Principle)</span></a></h1><blockquote><p>Many client-specific interfaces are better than one general-purpose interface.</p></blockquote><p>定义：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。</p><p>举个例子就是 <code>A</code> 接口有 <code>5</code> 个方法，<code>B</code> 类实现 <code>A</code> 接口，但 <code>B</code> 类只用到其中的 <code>3</code> 个方法，此时可以考虑对 <code>A</code> 接口进行拆分。</p><p><code>js</code> 中没有接口，忽略。</p><h1 id="依赖倒转原则-dip-dependency-inversion-principle" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则-dip-dependency-inversion-principle"><span>依赖倒转原则 DIP(Dependency Inversion Principle)</span></a></h1><blockquote><p>Depend upon abstractions, not concretions</p></blockquote><p>定义： 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>其实就是经常说的面向接口（或者基类）编程。</p><p>但 <code>js</code> 中没有接口和抽象类，这种原则也就用不到了。</p><p>上边五个原则就是经常看到的 <code>SOLID</code> 原则，除了这些还有几个其他的原则。</p><h1 id="最小知道原则-lod-principle-of-least-knowledge" tabindex="-1"><a class="header-anchor" href="#最小知道原则-lod-principle-of-least-knowledge"><span>最小知道原则 LOD(principle of least knowledge)</span></a></h1><p>定义：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>',19),q={href:"https://www.h7ml.cn/designPattern/appearance.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://en.wikipedia.org/wiki/Law_of_Demeter",target:"_blank",rel:"noopener noreferrer"},I=r('<blockquote><p><em>The Greek goddess of Agriculture.</em></p><p>The Demeter project was named after Demeter because we were working on a hardware description language Zeus and we were looking for a tool to simplify the implementation of Zeus. We were looking for a tool name related to Zeus and we chose a sister of Zeus: Demeter.</p><p>Later we promoted the idea that Demeter-style software development is about growing software as opposed to building software. We introduced the concept of a growth plan which is basically a sequence of more and more complex UML class diagrams.</p><p>Growth plans are useful for building systems incrementally.</p></blockquote><p>大意就是当时是用一个叫做 <code>Zeus</code> 的硬件语言，然后找到了一个优化 <code>Zens</code> 的工具，为了让它们产生联系，就起了 <code>Demeter</code> 这个名字。</p><figure><img src="http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.com25_29914_743225_ccd123bf574133ea11e60e85e7057014_38a998_301.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>另外截取一下 「JavaScript 设计开发与实现」书里提到的关于两个名字之间的建议：</p><blockquote><p>许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但本书参考 <em>Head First</em></p><p><em>Design Patterns</em> 的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因</p><p>是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必</p><p>须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难</p><p>以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，</p><p>要根据具体的环境来定。</p></blockquote><h1 id="合成-聚合复用原则-carp-composite-aggregate-reuse-principle" tabindex="-1"><a class="header-anchor" href="#合成-聚合复用原则-carp-composite-aggregate-reuse-principle"><span>合成/聚合复用原则 CARP(Composite/Aggregate Reuse Principle)</span></a></h1><p>定义：尽量使用合成/聚合，而不是通过继承达到复用的目的。</p><h1 id="kiss-原则" tabindex="-1"><a class="header-anchor" href="#kiss-原则"><span>KISS 原则</span></a></h1><p>定义： Keep It Simple, Stupid，在设计中应当注重简约的原则。</p><h1 id="yagni-原则" tabindex="-1"><a class="header-anchor" href="#yagni-原则"><span>YAGNI 原则</span></a></h1><p>定义：You aren&#39;t gonna need it，表示暂时不需要的就不要做。</p><h1 id="dry-原则" tabindex="-1"><a class="header-anchor" href="#dry-原则"><span>DRY 原则</span></a></h1><p>定义：Don&#39;t Repeat Yourself，不要写重复的代码。</p><h1 id="总" tabindex="-1"><a class="header-anchor" href="#总"><span>总</span></a></h1><p>所有的原则只是协助于我们写成易维护、易扩展的代码，不能为了去实现而实现、进行过度设计。</p><p>一些代码如果未来完全不用改变，那就用最简单的方式实现即可，当第二次、第三次修改的时候再来重构也不迟。</p><p>设计模式和基本原则的应用一定是结合具体场景的，空谈的话也没有任何意义。</p><p>我们只需要先了解这些原则，然后在日常开发中慢慢进行体会。</p>',18);function R(Z,L){const n=s("ExternalLinkIcon");return i(),p("div",null,[e("p",null,[t("二十三个经典的 "),e("a",l,[t("设计模式"),o(n)]),t(" 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。")]),d,h,m,g,e("p",null,[t("之前讲的 "),e("a",u,[t("代理模式"),o(n)]),t("、"),e("a",f,[t("装饰器模式"),o(n)]),t(" 都有体现。")]),b,w,_,y,k,e("p",null,[t("之前讲的 "),e("a",P,[t("发布订阅模式"),o(n)]),t("、"),e("a",v,[t("模版方法模式"),o(n)]),t("、"),e("a",x,[t("策略模式"),o(n)]),t("、"),e("a",S,[t("职责链模式"),o(n)]),t(" 都有体现。")]),D,e("p",null,[t("实体的话在前端中更多的对应对象、函数，"),e("a",q,[t("门面模式"),o(n)]),t(" 可以看作该原则的应用。")]),e("p",null,[t("最小知道原则又叫做迪米特法则 LOD(Law of Demeter)，迪米特其实是宙斯(Zeus) 的姐姐，名字来源的话这里截取下"),e("a",T,[t("维基百科"),o(n)]),t("。")]),I])}const N=a(c,[["render",R],["__file","basicPrinciple.html.vue"]]),B=JSON.parse('{"path":"/posts/designPattern/basicPrinciple.html","title":"基本原则","lang":"zh-CN","frontmatter":{"title":"基本原则","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-08T07:27:19.000Z","description":"二十三个经典的 设计模式 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。 单一职责原则 SRP(Single Responsibility Principle) There should never be more than one reason for a class to change.\\" In other words, ...","head":[["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/designPattern/basicPrinciple.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/designPattern/basicPrinciple.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"基本原则"}],["meta",{"property":"og:description","content":"二十三个经典的 设计模式 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。 单一职责原则 SRP(Single Responsibility Principle) There should never be more than one reason for a class to change.\\" In other words, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.h7ml.cn/logo.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-03T04:52:44.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://www.h7ml.cn/logo.png"}],["meta",{"name":"twitter:image:alt","content":"基本原则"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:tag","content":"frontend"}],["meta",{"property":"article:published_time","content":"2022-03-08T07:27:19.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-03T04:52:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基本原则\\",\\"image\\":[\\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.com25_29914_743225_ccd123bf574133ea11e60e85e7057014_38a998_301.jpg\\"],\\"datePublished\\":\\"2022-03-08T07:27:19.000Z\\",\\"dateModified\\":\\"2023-05-03T04:52:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[],"git":{"createdTime":1683089564000,"updatedTime":1683089564000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":1}]},"readingTime":{"minutes":5.62,"words":1687},"filePathRelative":"posts/designPattern/basicPrinciple.md","localizedDate":"2022年3月8日","excerpt":"<p>二十三个经典的 <a href=\\"https://www.h7ml.cn/designPattern/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">设计模式</a> 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。</p>\\n<h1>单一职责原则 SRP(Single Responsibility Principle)</h1>\\n<blockquote>\\n<p>There should never be more than one reason for a class to change.\\" In other words, every class should have only one responsibility.</p>\\n</blockquote>","autoDesc":true}');export{N as comp,B as data};
