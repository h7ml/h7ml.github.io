import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as l,c,d as e,e as a,a as n,f as o}from"./app-Cbix2SPG.js";const p={},r=o(`<h1 id="说说-flexbox-弹性盒布局模型-以及适用场景" tabindex="-1"><a class="header-anchor" href="#说说-flexbox-弹性盒布局模型-以及适用场景"><span>说说 flexbox（弹性盒布局模型）,以及适用场景？</span></a></h1><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/ef25b0a0-9837-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="一、是什么" tabindex="-1"><a class="header-anchor" href="#一、是什么"><span>一、是什么</span></a></h2><p><code>Flexible Box</code> 简称 <code>flex</code>，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局</p><p>采用 Flex 布局的元素，称为<code>flex</code>容器<code>container</code></p><p>它的所有子元素自动成为容器成员，称为<code>flex</code>项目<code>item</code></p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/fbc5f590-9837-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器中默认存在两条轴，主轴和交叉轴，呈 90 度关系。项目默认沿主轴排列，通过<code>flex-direction</code>来决定主轴的方向</p><p>每根轴都有起点和终点，这对于元素的对齐非常重要</p><h2 id="二、属性" tabindex="-1"><a class="header-anchor" href="#二、属性"><span>二、属性</span></a></h2><p>关于<code>flex</code>常用的属性，我们可以划分为容器属性和容器成员属性</p><p>容器属性有：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction" tabindex="-1"><a class="header-anchor" href="#flex-direction"><span>flex-direction</span></a></h3><p>决定主轴的方向(即项目的排列方向)</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>属性对应如下：</p><ul><li>row（默认值）：主轴为水平方向，起点在左端</li><li>row-reverse：主轴为水平方向，起点在右端</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿</li></ul><p>如下图所示：</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/0c9abc70-9838-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="flex-wrap" tabindex="-1"><a class="header-anchor" href="#flex-wrap"><span>flex-wrap</span></a></h3><p>弹性元素永远沿主轴排列，那么如果主轴排不下，通过<code>flex-wrap</code>决定容器内项目是否可换行</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>属性对应如下：</p><ul><li>nowrap（默认值）：不换行</li><li>wrap：换行，第一行在下方</li><li>wrap-reverse：换行，第一行在上方</li></ul><p>默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩</p><h3 id="flex-flow" tabindex="-1"><a class="header-anchor" href="#flex-flow"><span>flex-flow</span></a></h3><p>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;flex-direction&gt; || &lt;flex-wrap&gt;<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="justify-content" tabindex="-1"><a class="header-anchor" href="#justify-content"><span>justify-content</span></a></h3><p>定义了项目在主轴上的对齐方式</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>属性对应如下：</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等</li><li>space-around：两个项目两侧间隔相等</li></ul><p>效果图如下：</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="align-items" tabindex="-1"><a class="header-anchor" href="#align-items"><span>align-items</span></a></h3><p>定义项目在交叉轴上如何对齐</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>属性对应如下：</p><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline: 项目的第一行文字的基线对齐</li><li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度</li></ul><h3 id="align-content" tabindex="-1"><a class="header-anchor" href="#align-content"><span>align-content</span></a></h3><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>属性对应如吓：</p><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的终点对齐</li><li>center：与交叉轴的中点对齐</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li>stretch（默认值）：轴线占满整个交叉轴</li></ul><p>效果图如下：</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器成员属性如下：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h3 id="order" tabindex="-1"><a class="header-anchor" href="#order"><span>order</span></a></h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认为 0</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">order</span><span class="token punctuation">:</span> &lt;integer&gt;<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="flex-grow" tabindex="-1"><a class="header-anchor" href="#flex-grow"><span>flex-grow</span></a></h3><p>上面讲到当容器设为<code>flex-wrap: nowrap;</code>不换行的时候，容器宽度有不够分的情况，弹性元素会根据<code>flex-grow</code>来决定</p><p>定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展）</p><p>默认为<code>0</code>，即如果存在剩余空间，也不放大</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex-grow</span><span class="token punctuation">:</span> &lt;number&gt;<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/5b822b20-9838-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论<code>flex-grow</code>是什么值都不会生效</p><h3 id="flex-shrink" tabindex="-1"><a class="header-anchor" href="#flex-shrink"><span>flex-shrink</span></a></h3><p>定义了项目的缩小比例（容器宽度&lt;元素总宽度时如何收缩），默认为 1，即如果空间不足，该项目将缩小</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> &lt;number&gt;<span class="token punctuation">;</span> <span class="token comment">/* default 1 */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小</p><p>如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/658c5be0-9838-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在容器宽度有剩余时，<code>flex-shrink</code>也是不会生效的</p><h3 id="flex-basis" tabindex="-1"><a class="header-anchor" href="#flex-basis"><span>flex-basis</span></a></h3><p>设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸</p><p>浏览器根据这个属性，计算主轴是否有多余空间，默认值为<code>auto</code>，即项目的本来大小，如设置了<code>width</code>则元素尺寸由<code>width/height</code>决定（主轴方向），没有设置则由内容决定</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex-basis</span><span class="token punctuation">:</span> &lt;length&gt; | auto<span class="token punctuation">;</span> <span class="token comment">/* default auto */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当设置为 0 的是，会根据内容撑开</p><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间</p><h3 id="flex" tabindex="-1"><a class="header-anchor" href="#flex"><span>flex</span></a></h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>，也是比较难懂的一个复合属性</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> none | [ &lt; <span class="token string">&#39;flex-grow&#39;</span> &gt; &lt; <span class="token string">&#39;flex-shrink&#39;</span> &gt;? || &lt; <span class="token string">&#39;flex-basis&#39;</span> &gt;]<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一些属性有：</p><ul><li>flex: 1 = flex: 1 1 0%</li><li>flex: 2 = flex: 2 1 0%</li><li>flex: auto = flex: 1 1 auto</li><li>flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩</li></ul><p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别</p><p>当设置为 0 时（绝对弹性元素），此时相当于告诉<code>flex-grow</code>和<code>flex-shrink</code>在伸缩的时候不需要考虑我的尺寸</p><p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑</p><p>注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p><h3 id="align-self" tabindex="-1"><a class="header-anchor" href="#align-self"><span>align-self</span></a></h3><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</p><p>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果图如下：</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/interview/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、应用场景" tabindex="-1"><a class="header-anchor" href="#三、应用场景"><span>三、应用场景</span></a></h2><p>在以前的文章中，我们能够通过<code>flex</code>简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过<code>flex</code>完成，这里就不再展开代码的演示</p><p>包括现在在移动端、小程序这边的开发，都建议使用<code>flex</code>进行布局</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h2>`,95),d={href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex",target:"_blank",rel:"noopener noreferrer"},u={href:"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html",target:"_blank",rel:"noopener noreferrer"};function f(g,h){const s=i("ExternalLinkIcon");return l(),c("div",null,[r,e("ul",null,[e("li",null,[e("a",d,[a("https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"),n(s)])]),e("li",null,[e("a",u,[a("http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html"),n(s)])])])])}const b=t(p,[["render",f],["__file","flexbox.html.vue"]]),v=JSON.parse(`{"path":"/posts/interview/css/flexbox.html","title":"说说 flexbox（弹性盒布局模型）,以及适用场景？","lang":"zh-CN","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 flexbox（弹性盒布局模型）,以及适用场景？","order":5,"star":5,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 flexbox（弹性盒布局模型）,以及适用场景？"}],["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/interview/css/flexbox.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/interview/css/flexbox.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"说说 flexbox（弹性盒布局模型）,以及适用场景？"}],["meta",{"property":"og:description","content":"前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.h7ml.cn/logo.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-03T04:52:44.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://www.h7ml.cn/logo.png"}],["meta",{"name":"twitter:image:alt","content":"说说 flexbox（弹性盒布局模型）,以及适用场景？"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"interview"}],["meta",{"property":"article:tag","content":"css"}],["meta",{"property":"article:published_time","content":"2023-02-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-03T04:52:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"说说 flexbox（弹性盒布局模型）,以及适用场景？\\",\\"image\\":[\\"https://static.h7ml.cn/vitepress/assets/images/interview/ef25b0a0-9837-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/fbc5f590-9837-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/0c9abc70-9838-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/5b822b20-9838-11eb-ab90-d9ae814b240d.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/658c5be0-9838-11eb-85f6-6fac77c0c9b3.png\\",\\"https://static.h7ml.cn/vitepress/assets/images/interview/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png\\"],\\"datePublished\\":\\"2023-02-27T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-03T04:52:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[{"level":2,"title":"一、是什么","slug":"一、是什么","link":"#一、是什么","children":[]},{"level":2,"title":"二、属性","slug":"二、属性","link":"#二、属性","children":[{"level":3,"title":"flex-direction","slug":"flex-direction","link":"#flex-direction","children":[]},{"level":3,"title":"flex-wrap","slug":"flex-wrap","link":"#flex-wrap","children":[]},{"level":3,"title":"flex-flow","slug":"flex-flow","link":"#flex-flow","children":[]},{"level":3,"title":"justify-content","slug":"justify-content","link":"#justify-content","children":[]},{"level":3,"title":"align-items","slug":"align-items","link":"#align-items","children":[]},{"level":3,"title":"align-content","slug":"align-content","link":"#align-content","children":[]},{"level":3,"title":"order","slug":"order","link":"#order","children":[]},{"level":3,"title":"flex-grow","slug":"flex-grow","link":"#flex-grow","children":[]},{"level":3,"title":"flex-shrink","slug":"flex-shrink","link":"#flex-shrink","children":[]},{"level":3,"title":"flex-basis","slug":"flex-basis","link":"#flex-basis","children":[]},{"level":3,"title":"flex","slug":"flex","link":"#flex","children":[]},{"level":3,"title":"align-self","slug":"align-self","link":"#align-self","children":[]}]},{"level":2,"title":"三、应用场景","slug":"三、应用场景","link":"#三、应用场景","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{"createdTime":1683089564000,"updatedTime":1683089564000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":1}]},"readingTime":{"minutes":6.22,"words":1865},"filePathRelative":"posts/interview/css/flexbox.md","localizedDate":"2023年2月27日","excerpt":"\\n<figure><img src=\\"https://static.h7ml.cn/vitepress/assets/images/interview/ef25b0a0-9837-11eb-ab90-d9ae814b240d.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<h2>一、是什么</h2>\\n<p><code>Flexible Box</code> 简称 <code>flex</code>，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局</p>\\n<p>采用 Flex 布局的元素，称为<code>flex</code>容器<code>container</code></p>"}`);export{b as comp,v as data};
