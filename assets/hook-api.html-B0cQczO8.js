import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as n,c as a,b as i,d as e,e as s,a as d,f as l}from"./app-Cbix2SPG.js";const r={},p=l('<h2 id="useeffect-依赖执行关系" tabindex="-1"><a class="header-anchor" href="#useeffect-依赖执行关系"><span>useEffect 依赖执行关系</span></a></h2><p><code>useEffect</code> 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 <code>fiber</code> 创建 <code>Passive Effect</code> 的？</p><ol><li>不包含第二个参数 <code>useEffect(() =&gt; {})</code>，<code>Mount</code> &amp; <code>Update</code> 时，每次 <code>render</code> 时都会创建一个 <code>Passive Effect</code>;</li><li>包含一个空数组[]作为依赖项 <code>useEffect(() =&gt; {}, [])</code>，它会在 <code>mount</code> 时，创建 <code>Passive Effect</code></li><li>包含一个依赖项<code>[dep]</code>，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect</li></ol><h2 id="fn-和-componentdidmount-的执行时机分别是什么" tabindex="-1"><a class="header-anchor" href="#fn-和-componentdidmount-的执行时机分别是什么"><span>fn 和 componentDidMount 的执行时机分别是什么？</span></a></h2><p><strong>过程</strong></p><p>render 阶段到 commit 阶段，传递的时包含不同 fiber 节点的 effect 的链表，commit 阶段时将状态变化（Effect）渲染在视图中</p><ul><li>渲染视图前，beforeMutation 阶段</li><li>渲染视图中，mutation 阶段，Placement 会执行 appendChild，DOM 节点插入到视图中</li><li>渲染视图后，layout 阶段，调用 componentDidMount</li></ul><ol><li>useEffect 时 commit 完成后异步调用</li><li>componentDidMount 是 commit 阶段完成视图更新（mutation 阶段）后，在 layout 阶段同步调用</li><li>useLayoutEffect 和 componentDidMount 调用时机一致，也是在 layout 阶段同步调用</li></ol><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',9),f=e("h2",{id:"相关文章",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#相关文章"},[e("span",null,"相关文章")])],-1),m={href:"https://www.yuque.com/lxylona/note/tlc8hz#RnPvS",target:"_blank",rel:"noopener noreferrer"};function u(h,g){const t=c("ExternalLinkIcon");return n(),a("div",null,[p,i(" `useEffect` 可以看成 `componentDidMount / componentDidUpdate / componentWillUnmount` 这 3 个生命周期函数的替代。\n\n但其实他们并不是完全等价，**useEffect 是在浏览器渲染结束之后才执行的，而这三个生命周期函数是在浏览器渲染之前同步执行的**，React 还有一个官方的 hook 是完全等价于这三个生命周期函数的，叫 useLayoutEffect。 "),f,e("ul",null,[e("li",null,[e("a",m,[s("React Hooks: 深入剖析 useMemo 和 useEffect"),d(t)])])])])}const k=o(r,[["render",u],["__file","hook-api.html.vue"]]),_=JSON.parse('{"path":"/posts/react/hook-api.html","title":"hook-api","lang":"zh-CN","frontmatter":{"icon":"react","order":2,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"hook-api","category":"react","tag":["react","hook"],"star":true,"lastUpdated":false,"description":"useEffect 依赖执行关系 useEffect 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 fiber 创建 Passive Effect 的？ 不包含第二个参数 useEffect(() => {})，Mount & Update 时，每次 render 时都会创建一个 Passive Effect; 包含一个空数...","head":[["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/react/hook-api.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/react/hook-api.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"hook-api"}],["meta",{"property":"og:description","content":"useEffect 依赖执行关系 useEffect 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 fiber 创建 Passive Effect 的？ 不包含第二个参数 useEffect(() => {})，Mount & Update 时，每次 render 时都会创建一个 Passive Effect; 包含一个空数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-03T04:52:44.000Z"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"hook"}],["meta",{"property":"article:published_time","content":"2021-07-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-03T04:52:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"hook-api\\",\\"image\\":[\\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png\\"],\\"datePublished\\":\\"2021-07-12T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-03T04:52:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[{"level":2,"title":"useEffect 依赖执行关系","slug":"useeffect-依赖执行关系","link":"#useeffect-依赖执行关系","children":[]},{"level":2,"title":"fn 和 componentDidMount 的执行时机分别是什么？","slug":"fn-和-componentdidmount-的执行时机分别是什么","link":"#fn-和-componentdidmount-的执行时机分别是什么","children":[]},{"level":2,"title":"相关文章","slug":"相关文章","link":"#相关文章","children":[]}],"git":{"createdTime":1683089564000,"updatedTime":1683089564000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":1}]},"readingTime":{"minutes":1.37,"words":411},"filePathRelative":"posts/react/hook-api.md","localizedDate":"2021年7月12日","excerpt":"<h2>useEffect 依赖执行关系</h2>\\n<p><code>useEffect</code> 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 <code>fiber</code> 创建 <code>Passive Effect</code> 的？</p>\\n<ol>\\n<li>不包含第二个参数 <code>useEffect(() =&gt; {})</code>，<code>Mount</code> &amp; <code>Update</code> 时，每次 <code>render</code> 时都会创建一个 <code>Passive Effect</code>;</li>\\n<li>包含一个空数组[]作为依赖项 <code>useEffect(() =&gt; {}, [])</code>，它会在 <code>mount</code> 时，创建 <code>Passive Effect</code></li>\\n<li>包含一个依赖项<code>[dep]</code>，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect</li>\\n</ol>","autoDesc":true}');export{k as comp,_ as data};
