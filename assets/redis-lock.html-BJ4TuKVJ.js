import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as e}from"./app-Cbix2SPG.js";const t={},p=e(`<h2 id="不可重入锁" tabindex="-1"><a class="header-anchor" href="#不可重入锁"><span>不可重入锁</span></a></h2><p>即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。</p><h2 id="可重入锁" tabindex="-1"><a class="header-anchor" href="#可重入锁"><span>可重入锁</span></a></h2><p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。</p><h3 id="可重入锁作用" tabindex="-1"><a class="header-anchor" href="#可重入锁作用"><span>可重入锁作用</span></a></h3><p>防止在同一线程中多次获取锁而导致死锁发生</p><blockquote><p>在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁</p></blockquote><p>用一段 Java 代码解释可重入：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">lockA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">lockB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">lockB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// pass</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设 X 线程在 lockA 方法获取锁之后，继续执行 lockB 方法，如果此时不可重入，线程就必须等待锁释放，再次争抢锁。</p><p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p><h2 id="reentrantlock-可重入锁源码思路" tabindex="-1"><a class="header-anchor" href="#reentrantlock-可重入锁源码思路"><span>ReentrantLock 可重入锁源码思路</span></a></h2><h3 id="加锁" tabindex="-1"><a class="header-anchor" href="#加锁"><span>加锁</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * ReentrantLock的加锁流程是：
 * 1，先判断是否有线程持有锁，没有加锁进行加锁
 * 2、如果加锁成功，则设置持有锁的线程是当前线程
 * 3、如果有线程持有了锁，则再去判断，是否是当前线程持有了锁
 * 4、如果是当前线程持有锁，则加锁数量（state）+1
 */</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//先判断，c（state）是否等于0，如果等于0，说明没有线程持有锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//通过cas方法把state的值0替换成1，替换成功说明加锁成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果加锁成功，设置持有锁的线程是当前线程</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//判断当前持有锁的线程是否是当前线程</span>
        <span class="token comment">//如果是当前线程，则state值加acquires，代表了当前线程加锁了多少次</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解锁" tabindex="-1"><a class="header-anchor" href="#解锁"><span>解锁</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 看ReentrantLock的解锁代码我们知道，每次释放锁的时候都对state减1，
 * 当c值等于0的时候，说明锁重入次数也为0了，
 * 最终设置当前持有锁的线程为null,state也设置为0，锁就释放了。
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span><span class="token comment">//state-1 减加锁次数</span>
    <span class="token comment">//如果持有锁的线程，不是当前线程，抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果c==0了说明当前线程，已经要释放锁了</span>
        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置当前持有锁的线程为null</span>
    <span class="token punctuation">}</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置c的值</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分布式重入锁-redisson-依然实现-但此处注重原理实现" tabindex="-1"><a class="header-anchor" href="#分布式重入锁-redisson-依然实现-但此处注重原理实现"><span>分布式重入锁（redisson 依然实现，但此处注重原理实现）</span></a></h2><p>基于 ReentrantLock 的源码我们知道，它是加锁成功了，记录了当前持有锁的线程，并通过一个 int 类型的数字，来记录了加锁次数。我们知道 ReentrantLock 的实现原理了，那么 redis 只要下面两个问题解决，就能实现重入锁了：</p><h3 id="_1-如何保存现有的线程" tabindex="-1"><a class="header-anchor" href="#_1-如何保存现有的线程"><span>1.如何保存现有的线程</span></a></h3><p>ReentrantLock 使用的是当前线程内存地址进行对比，那么我们就可以使用线程的 ID 进行比较一样可以的。但是在分布式环境下，这个 ID 就可能会存在重复，此时，我们需要增加一个全局的唯一 ID + 线程 ID 来做一个分布式线程比较。</p><h3 id="_2-加锁次数-重入了多少次-怎么记录维护" tabindex="-1"><a class="header-anchor" href="#_2-加锁次数-重入了多少次-怎么记录维护"><span>2.加锁次数（重入了多少次），怎么记录维护</span></a></h3><p>他能记录下来加锁次数吗？如果 valus 值存的格式是：系进程 id+线程 id+加锁次数，那可以实现存没问题了，但是重入次数要怎么维护了， 它肯定要保证原子性的，能解决吗？好像用 java 代码或者 lua 脚本都没法解决，因为都是实现都需要两步来维护这个重入次数的</p><ul><li>第一步：先获取到 valus 值，把取到加锁次数+1</li><li>第二步：把新的值再设置进去在执行第二步操作之前，如果这个 key 失效了（设置持有锁超时了），如果还能再设置进去，就会有并发问题了</li></ul><h2 id="redisson-是如何实现的" tabindex="-1"><a class="header-anchor" href="#redisson-是如何实现的"><span>Redisson 是如何实现的</span></a></h2><p>我们跟一下 lock.lock()的代码，发现它最终调用的是 org.redisson.RedissonLock#tryLockInnerAsync 的方法,具体如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisStrictCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> command<span class="token punctuation">,</span>
            <span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
                    <span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分析一下-redis-命令" tabindex="-1"><a class="header-anchor" href="#分析一下-redis-命令"><span>分析一下 redis 命令</span></a></h3><ol><li>exists 查询一个 key 是否存在</li><li>hincrby ：将 hash 中指定域的值增加给定的数字</li><li>pexpire：设置 key 的有效时间以毫秒为单位</li><li>hexists：判断 field 是否存在于 hash 中</li><li>pttl：获取 key 的有效毫秒数</li><li>KEYS[1] = key 的值</li><li>ARGV[1]) = 持有锁的时间</li><li>ARGV[2] = getLockName(threadId) 下面 id 就算系统在启动的时候会全局生成的 uuid 来作为当前进程的 id，加上线程 id 就是 getLockName(threadId)了，可以理解为：进程 ID+系统 ID = ARGV[2] 主要也是使用了 lua 脚本来保证多个命令执行的原子性，使用了 hash 来实现了分布式锁</li></ol><h3 id="lua-脚本的加锁流程" tabindex="-1"><a class="header-anchor" href="#lua-脚本的加锁流程"><span>lua 脚本的加锁流程</span></a></h3><figure><img src="https://static.h7ml.cn/vitepress/assets/images/redis-lua.png" alt="redis-lua.png" tabindex="0" loading="lazy"><figcaption>redis-lua.png</figcaption></figure><h4 id="_1、第一个-if-判断" tabindex="-1"><a class="header-anchor" href="#_1、第一个-if-判断"><span>1、第一个 if 判断</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>204行：它是先判断了当前key是否存在，从EXISTS命令我们知道返回值是0说明key不存在，说明没有加锁
205行：hincrby命令是对 ARGV[2] = 进程ID+系统ID 进行原子自增加1
206行：是对整个hash设置过期期间
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2、下面来看第二个-if-判断" tabindex="-1"><a class="header-anchor" href="#_2、下面来看第二个-if-判断"><span>2、下面来看第二个 if 判断</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>209行：判断field是否存在于hash中，如果存在返回1，返回1说明是当前进程+当前线程ID 之前已经获得到锁了
210行：hincrby命令是对 ARGV[2] = 进程ID+系统ID 进行原子自增加1，说明重入次数加1了
211行：再对整个hash设置过期期间
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：分布式锁有过期时间，默认-1 的时候是需要自动续期的（redisson 有看门狗自动续期），当服务 down 机后自然自动释放解锁过程和 Reentrantlock 的解锁逻辑也基本相同没啥好说的了</p>`,35),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","redis-lock.html.vue"]]),k=JSON.parse('{"path":"/posts/redis/redis-lock.html","title":"redis实现分布式可重入锁","lang":"zh-CN","frontmatter":{"icon":"wrap","order":2,"date":"2019-08-05T00:00:00.000Z","author":"h7ml","title":"redis实现分布式可重入锁","category":"redis","tag":"redis","star":false,"description":"不可重入锁 即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。 可重入锁 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。 可重入锁作用 防止在同一线程中多次获取锁而导致死锁发生 在...","head":[["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/redis/redis-lock.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/redis/redis-lock.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"redis实现分布式可重入锁"}],["meta",{"property":"og:description","content":"不可重入锁 即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。 可重入锁 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。 可重入锁作用 防止在同一线程中多次获取锁而导致死锁发生 在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://static.h7ml.cn/vitepress/assets/images/redis-lua.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-03T04:52:44.000Z"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2019-08-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-03T04:52:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis实现分布式可重入锁\\",\\"image\\":[\\"https://static.h7ml.cn/vitepress/assets/images/redis-lua.png\\"],\\"datePublished\\":\\"2019-08-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-03T04:52:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[{"level":2,"title":"不可重入锁","slug":"不可重入锁","link":"#不可重入锁","children":[]},{"level":2,"title":"可重入锁","slug":"可重入锁","link":"#可重入锁","children":[{"level":3,"title":"可重入锁作用","slug":"可重入锁作用","link":"#可重入锁作用","children":[]}]},{"level":2,"title":"ReentrantLock 可重入锁源码思路","slug":"reentrantlock-可重入锁源码思路","link":"#reentrantlock-可重入锁源码思路","children":[{"level":3,"title":"加锁","slug":"加锁","link":"#加锁","children":[]},{"level":3,"title":"解锁","slug":"解锁","link":"#解锁","children":[]}]},{"level":2,"title":"分布式重入锁（redisson 依然实现，但此处注重原理实现）","slug":"分布式重入锁-redisson-依然实现-但此处注重原理实现","link":"#分布式重入锁-redisson-依然实现-但此处注重原理实现","children":[{"level":3,"title":"1.如何保存现有的线程","slug":"_1-如何保存现有的线程","link":"#_1-如何保存现有的线程","children":[]},{"level":3,"title":"2.加锁次数（重入了多少次），怎么记录维护","slug":"_2-加锁次数-重入了多少次-怎么记录维护","link":"#_2-加锁次数-重入了多少次-怎么记录维护","children":[]}]},{"level":2,"title":"Redisson 是如何实现的","slug":"redisson-是如何实现的","link":"#redisson-是如何实现的","children":[{"level":3,"title":"分析一下 redis 命令","slug":"分析一下-redis-命令","link":"#分析一下-redis-命令","children":[]},{"level":3,"title":"lua 脚本的加锁流程","slug":"lua-脚本的加锁流程","link":"#lua-脚本的加锁流程","children":[]}]}],"git":{"createdTime":1683089564000,"updatedTime":1683089564000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":1}]},"readingTime":{"minutes":5.65,"words":1694},"filePathRelative":"posts/redis/redis-lock.md","localizedDate":"2019年8月5日","excerpt":"<h2>不可重入锁</h2>\\n<p>即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。</p>\\n<h2>可重入锁</h2>\\n<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。</p>\\n<h3>可重入锁作用</h3>\\n<p>防止在同一线程中多次获取锁而导致死锁发生</p>\\n<blockquote>\\n<p>在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁</p>\\n</blockquote>","autoDesc":true}');export{d as comp,k as data};
